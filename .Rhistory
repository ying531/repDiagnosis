X1= org.dat[,c("age","constant")]
sapply(X1, sd)
min(sapply(X1, sd))
covariate_formula="~age"
org_df = org.dat
rep_df = rep.dat
# extract covariates and check whether it behaves normally
X1 = tryCatch({model.matrix(formula(covariate_formula), data=org_df)},
error = function(e) { return(NA) })
X2 = tryCatch({model.matrix(formula(covariate_formula), data=rep_df)},
error = function(e) { return(NA) })
X1
X1[,2:ncol(X1)]
dim(X1[,2:ncol(X1)])
is.null(dim(X1[,2:ncol(X1)]))
min(sapply(X1[,2:ncol(X1)], sd))==0
covariate_formula
devtools::document()
devtools::build()
devtools::check_rhub()
devtools::build()
devtools::check_rhub()
devtools::check_win_devel()
devtools::check_rhub()
data("emdr_misinfo")
analysis_formula = "rating ~ condition"
treatment_name = "condition"
head(org.dat)
id_name_1 = id_name_2 = "X"
covariates = c("age", "gender")
mediators = c("postvividness", "postemotionality")
results = run_diagnosis()
library(repDiagnosis)
results = run_diagnosis(
org_df = org.dat,
rep_df = rep.dat,
analysis_formula = analysis_formula,
treatment_name = treatment_name,
id_name_1 = "X",
id_name_2 = "X",
covariates = covariates,
mediators = mediators,
alpha = 0.1, # confidence level for all CIs
verbose = TRUE, # printing the tables and plots
if_selective = TRUE, # conduct the selective inference CIs
pub_pvalue_threshold = 0.05, # p-value threshold for publication bias
)
library(tidyverse)
library(ebal)
library(sandwich)
library(progress)
library(lmtest)
results = run_diagnosis(
org_df = org.dat,
rep_df = rep.dat,
analysis_formula = analysis_formula,
treatment_name = treatment_name,
id_name_1 = "X",
id_name_2 = "X",
covariates = covariates,
mediators = mediators,
alpha = 0.1, # confidence level for all CIs
verbose = TRUE, # printing the tables and plots
if_selective = TRUE, # conduct the selective inference CIs
pub_pvalue_threshold = 0.05, # p-value threshold for publication bias
)
analysis_formula = "totalcorrect ~ condition"
results = run_diagnosis(
org_df = org.dat,
rep_df = rep.dat,
analysis_formula = analysis_formula,
treatment_name = treatment_name,
id_name_1 = "X",
id_name_2 = "X",
covariates = covariates,
mediators = mediators,
alpha = 0.1, # confidence level for all CIs
verbose = TRUE, # printing the tables and plots
if_selective = TRUE, # conduct the selective inference CIs
pub_pvalue_threshold = 0.05, # p-value threshold for publication bias
)
run_diagnosis <- function(
org_df,
rep_df,
analysis_formula, # = "pv ~ treatment + factor(delay)*factor(fv)"
treatment_name,
id_name_1 = NULL,
id_name_2 = NULL,
covariate_formula = NULL, # covariate formula, take formula over covariates if both are present = "~ practice_religion + religion + race"
covariates = NULL, # a vector containing the column names of covariates
mediation_formula = NULL, # = "~ (practice_religion + religion + race + panas + happiness_induced + mood_induced)*treatment"
mediators = NULL, # a vector containing the column names of mediators
alpha = 0.1, # confidence intervals are 1-alpha coverage
verbose = TRUE,
if_selective = TRUE, # whether to run selective inference CIs
pub_pvalue_threshold = 0.05 # p-value threshold for publication bias
){
#####################################################
######### sanity check for covariate inputs #########
#####################################################
# if covariate formula is provided, check whether it results in correct subset data
if (!is.null(covariate_formula)){
X1 = tryCatch({model.matrix(formula(covariate_formula), data=org_df)},
error = function(e) { return(NA) })
X2 = tryCatch({model.matrix(formula(covariate_formula), data=rep_df)},
error = function(e) { return(NA) })
if (is.na(X1) || is.na(X2)){
stop("Covariate formula incorrect! \n")
}else{# extract covariate names into a vector
covariates = colnames(X1)[2:ncol(X1)]
}
}else{ # if covariate formula is not provided
if (is.null(covariates)){ # if covariates are also not provided
stop("Please provide covariate formula or covariates! \n")
}else{ # when covariates are present
# turn to names if there are numerical indicators
for (i.par in 1:length(covariates)){
if (!is.na(suppressWarnings(as.integer(covariates[i.par])))){
covariates[i.par] = colnames(org_df)[as.integer(covariates[i.par])]
}
}
covariate_formula = paste("~", paste(covariates, collapse = "+"))
}
# extract covariates and check whether it behaves normally
X1 = tryCatch({model.matrix(formula(covariate_formula), data=org_df)},
error = function(e) { return(NA) })
X2 = tryCatch({model.matrix(formula(covariate_formula), data=rep_df)},
error = function(e) { return(NA) })
if (is.na(X1) || is.na(X2)){ # any of the data fails to be extracted
stop("Covariate input does not work! \n")
}else{# extract covariate names into a vector
covariates = colnames(X1)[2:ncol(X1)]
if (is.null(dim(X1[,2:ncol(X1)]))){
if (sd(X1[,2:ncol(X1)])==0){stop("Constant covariate error! \n")}
}
}
}
#####################################################
######### sanity check for mediator inputs ##########
#####################################################
mediators_all = NULL
if (!is.null(mediation_formula)){
X1 = tryCatch({model.matrix(formula(mediation_formula), data=org_df)},
error = function(e) { return(NA) })
X2 = tryCatch({model.matrix(formula(mediation_formula), data=rep_df)},
error = function(e) { return(NA) })
if (is.na(X1) || is.na(X2)){# any of the data fails to be extracted
cat("Mediation formula incorrect! \n")
stop()
}else{
mediators_all = colnames(X1)[2:ncol(X1)]
}
}else{ # if mediation formula is not provided
if (!is.null(mediators) && length(mediators) > 0){ # if mediators are provided
# turn to names if there are numerical indicators
for (i.par in 1:length(mediators)){
if (!is.na(suppressWarnings(as.integer(mediators[i.par])))){
mediators[i.par] = colnames(org_df)[as.integer(mediators[i.par])]
}
}
# check whether the mediator is constant
if (length(mediators)==1){
if (sd(org_df[mediators[1]])==0 || sd(rep_df[mediators[1]])==0){
stop("Constant mediator error! \n")
}
}
# generate mediation formula
mediation_formula = paste("~(", paste(covariates, collapse="+"), "+", paste(mediators, collapse = "+"), ")*", treatment_name)
# extract covariates and check whether it behaves normally
X1 = tryCatch({model.matrix(formula(mediation_formula), data=org_df)},
error = function(e) { return(NA) })
X2 = tryCatch({model.matrix(formula(mediation_formula), data=rep_df)},
error = function(e) { return(NA) })
if (is.na(X1) || is.na(X2)){ # any of the data fails to be extracted
stop("Mediator input does not work! \n")
}else{
mediators_all = colnames(X1)[2:ncol(X1)]
}
}
}
####################################################
######### sanity check for cluster inputs ##########
####################################################
clusters_1 = NULL
clusters_2 = NULL
# make sure both ids are present
if ((is.null(id_name_1) && !is.null(id_name_2)) || (is.null(id_name_2) && !is.null(id_name_1))){
stop("Please provide both group IDs!")
}
# if both are provided, generate cluster variables
if (!is.null(id_name_1) && !is.null(id_name_2)){
# generate cluster variables
cluster_1 = c(treatment_name, covariates, mediators_all, id_name_1)
cluster_2 = c(treatment_name, covariates, mediators_all, id_name_2)
}
####################################################
######### decomposition diagnosis ##########
####################################################
org_df = data.frame(org_df)
rep_df = data.frame(rep_df)
results = .decomposition(
data1 = org_df,
data2 = rep_df,
analysis_formula = analysis_formula,
treatment_variable = treatment_name,
covariate_formula = covariate_formula,
mediation_formula = mediation_formula,
clusters_1 = clusters_1,
clusters_2 = clusters_2
)
# choose the cluster id if it is not null
if (!is.null(id_name_1) && !(id_name_1 == '')){
id1 = unique(org_df[,id_name_1])
}else{
id1 = 1:dim(org_df)[1]
}
if (!is.null(id_name_2) && !(id_name_2 == '')){
id2 = unique(rep_df[,id_name_2])
}else{
id2 = 1:dim(rep_df)[1]
}
N1 = length(id1)
N2 = length(id2)
phi1 = phi2 = data.frame()
pb = progress_bar$new("Jackknifing [:bar] :percent", total=N1 + N2, width=80)
total_steps <- N1 + N2
for (i in 1:N1) {
pb$tick()
if (!is.null(id_name_1) && !(id_name_1 == '')){
sub.org_df = filter(org_df, !!sym(id_name_1) != id1[i])
}else{
sub.org_df = org_df[-i,]
}
try({phi1 = bind_rows(phi1, .decomposition(
data1 = sub.org_df,
data2 = rep_df,
analysis_formula = analysis_formula,
treatment_variable = treatment_name,
covariate_formula = covariate_formula,
mediation_formula = mediation_formula,
clusters_1 = clusters_1,
clusters_2 = clusters_2
)$decomp)}, silent = TRUE)
}
for (i in 1:N2) {
pb$tick()
if (!is.null(id_name_2) && !(id_name_2 == '')){
sub.rep_df = rep_df[rep_df[,id_name_2]!=id2[i],]
}else{
sub.rep_df = rep_df[-i,]
}
try({phi2 = bind_rows(phi2, .decomposition(
data1 = org_df,
data2 = sub.rep_df,
analysis_formula = analysis_formula,
treatment_variable = treatment_name,
covariate_formula = covariate_formula,
mediation_formula = mediation_formula,
clusters_1 = clusters_1,
clusters_2 = clusters_2
)$decomp)}, silent = TRUE)
}
phi1 = phi1 %>% drop_na()
phi2 = phi2 %>% drop_na()
if (nrow(phi1) == 0 || nrow(phi2) == 0){
stop("Inference incorrect due to specification errors! \n")
}
SEs = sqrt(apply(phi1, 2, var)*(nrow(phi1)-1)^2/N1 + apply(phi2, 2, var)*(nrow(phi2)-1)^2/N2)
Sigma = var(phi1)*(nrow(phi1)-1)^2/N1 + var(phi2)*(nrow(phi2)-1)^2/N2
# ==================================================
# Plotting results
bounds = cbind(as.numeric(results$decomp),
as.numeric(results$decomp) - qnorm(0.95)*SEs,
as.numeric(results$decomp) + qnorm(0.95)*SEs) %>% data.frame()
pvals = 2 - 2 * pnorm(abs(as.numeric(results$decomp))/SEs)
colnames(bounds) = c("estimate", "low", "high")
bounds$component = rownames(bounds)
if (!is.null(mediation_formula)){
decomp.plot = bounds %>% filter(component != "Original") %>%
mutate(component = factor(component, levels = c("Observed", "Covariates", "Mediators", "Residual"))) %>%
ggplot(aes(x = component, fill = component, y = estimate, ymin = low, ymax = high)) +
geom_crossbar(aes(alpha = 0.8, col = component), width=0.5) +
theme_bw() + xlab("") + ylab("") +
# theme(legend.position = "None") +
geom_hline(yintercept = 0, lty=2)+
theme(text= element_text(family="Times", size=15),
axis.text= element_text(family="Times", size=12),
strip.text.x= element_text(family="Times", size=12),
strip.text.y= element_text(family="Times", size=12),
legend.title = element_text(family="Times", size=15),
legend.position="None",
plot.title = element_text(family="Times", size=15, hjust = 0.5))
ret_table = cbind(as.numeric(results$decomp), SEs, as.numeric(results$decomp)/SEs, pvals)
colnames(ret_table) = c("Estimate", "Std. Error", "t-stat", "Pr(>|z|)")
rownames(ret_table) = c("Original", "Observed", "Covariates", "Mediators", "Residual")
ret_table_df <- as.data.frame(ret_table)
ret_table_df$Component <- rownames(ret_table)
ret_table_df <- ret_table_df[, c("Component", "Estimate", "Std. Error", "t-stat", "Pr(>|z|)")]
if (verbose){ # print summary table
cat("\n")
cat("Summary of decomposition for replication diagnosis:")
cat("\n\n")
print(ret_table)
cat("\n")
print(decomp.plot)
}
# ==============================================================
# Accounting for publication bias at the p = pub_pvalue_threshold level
if (if_selective){
threshold = qnorm(1-pub_pvalue_threshold/2)*summary(lm(analysis_formula, data = org_df))$coefficients[treatment_name, "Std. Error"]
components = c("Observed", "Covariates", "Mediators", "Residual")
bounds = lapply(components, FUN = function(v) {
.selective_ci(
x = results$decomp[c(v, "Original")],
sigma = Sigma[c(v, "Original"), c(v, "Original")],
threshold = threshold,
alpha = alpha
)}) %>% bind_rows()
bounds$component = components
ret_table_sel = data.frame(bounds[,c("low", "high", "estimate")])
rownames(ret_table_sel) = components
# generate error message
sel.message = ""
bounds.sel.tp = data.frame()
for (v in 1:length(components)){
if ((bounds$low[v] == -Inf) || (bounds$high[v] == Inf)){
sel.message = paste(sel.message,
"No meaningful selective CI within [",
bounds$lowest[v], bounds$highest[v],"] for ",
components[v], "component! \n")
}else{
to.add = ret_table_sel[v,]
if ((bounds$estimate[v] == -Inf) || (bounds$estimate[v] < bounds$low[v]) || (bounds$estimate[v] > bounds$high[v])){
to.add$estimate = (to.add$low + to.add$high)/2
}
bounds.sel.tp = rbind(bounds.sel.tp, to.add)
}
}
if (nrow(bounds.sel.tp)>0){
bounds.sel.tp$components = rownames(bounds.sel.tp)
selective.plt = bounds.sel.tp %>%
mutate(component = factor(components, levels = c("Original", "Observed", "Covariates", "Mediators", "Residual"))) %>%
ggplot(aes(x = component, fill = component, y = estimate, ymin = low, ymax = high)) +
geom_crossbar(aes(col = component), alpha = 0.5, width=0.6) +
theme_bw() + xlab("") + ylab("") +
theme(legend.position = "None") +
geom_hline(yintercept = 0, lty=2) +
theme(text= element_text(family="Times", size=15),
axis.text= element_text(family="Times", size=12),
strip.text.x= element_text(family="Times", size=12),
strip.text.y= element_text(family="Times", size=12),
legend.title = element_text(family="Times", size=15),
legend.position="None",
plot.title = element_text(family="Times", size=15, hjust = 0.5))
}else{
selective.plt = NULL
}
}
if (verbose){ # print summary table
cat("\n")
cat("Summary of post-selective decomposition for replication diagnosis:")
cat("\n\n")
print(ret_table_sel)
cat("\n")
if (!is.null(selective.plt)){
print(selective.plt)
}
}
}else{
###### mediation formula is null
decomp.plot = bounds %>% filter(component != "Original") %>%
mutate(component = factor(component, levels = c("Observed", "Covariates", "Residual"))) %>%
ggplot(aes(x = component, fill = component, y = estimate, ymin = low, ymax = high)) +
geom_crossbar(aes(alpha = 0.8, col = component), width=0.5) +
theme_bw() + xlab("") + ylab("") +
geom_hline(yintercept = 0, lty=2)+
theme(text= element_text(family="Times", size=15),
axis.text= element_text(family="Times", size=12),
strip.text.x= element_text(family="Times", size=12),
strip.text.y= element_text(family="Times", size=12),
legend.title = element_text(family="Times", size=15),
legend.position="None",
plot.title = element_text(family="Times", size=15, hjust = 0.5))
ret_table = cbind(as.numeric(results$decomp), SEs, as.numeric(results$decomp)/SEs, pvals)
colnames(ret_table) = c("Estimate", "Std. Error", "t-stat", "Pr(>|z|)")
rownames(ret_table) = c("Original", "Observed", "Covariates", "Residual")
ret_table_df <- as.data.frame(ret_table)
ret_table_df$Component <- rownames(ret_table)
ret_table_df <- ret_table_df[, c("Component", "Estimate", "Std. Error", "t-stat", "Pr(>|z|)")]
if (verbose){ # print summary table
cat("\n")
cat("Summary of decomposition for replication diagnosis:")
cat("\n\n")
print(ret_table)
cat("\n")
print(decomp.plot)
}
# ==============================================================
# Accounting for publication bias at the p = pub_pvalue_threshold level
if (if_selective){
threshold = qnorm(1-pub_pvalue_threshold/2)*summary(lm(analysis_formula, data = org_df))$coefficients[treatment_name, "Std. Error"]
components = c("Observed", "Covariates", "Residual")
bounds = lapply(components, FUN = function(v) {
.selective_ci(
x = results$decomp[c(v, "Original")],
sigma = Sigma[c(v, "Original"), c(v, "Original")],
threshold = threshold,
alpha = alpha
)}) %>% bind_rows()
bounds$component = components
ret_table_sel = data.frame(bounds[,c("low", "high", "estimate")])
rownames(ret_table_sel) = components
# generate error message
sel.message = ""
bounds.sel.tp = data.frame()
for (v in 1:length(components)){
if ((bounds$low[v] == -Inf) || (bounds$high[v] == Inf)){
sel.message = paste(sel.message,
"No meaningful selective CI within [",
bounds$lowest[v], bounds$highest[v],"] for ",
components[v], "component! <br>")
}else{
to.add = ret_table_sel[v,]
if  ((bounds$estimate[v] == -Inf) || (bounds$estimate[v] < bounds$low[v]) || (bounds$estimate[v] > bounds$high[v])){
to.add$estimate = (to.add$low + to.add$high)/2
}
bounds.sel.tp = rbind(bounds.sel.tp, to.add)
}
}
if (nrow(bounds.sel.tp)>0){
bounds.sel.tp$components = rownames(bounds.sel.tp)
selective.plt = bounds.sel.tp %>%
mutate(component = factor(components, levels = c("Original", "Observed", "Covariates", "Mediators", "Residual"))) %>%
ggplot(aes(x = component, fill = component, y = estimate, ymin = low, ymax = high)) +
geom_crossbar(aes(col = component), alpha = 0.8, width=0.5) +
theme_bw() + xlab("") + ylab("") +
theme(legend.position = "None") +
geom_hline(yintercept = 0, lty=2) +
theme(text= element_text(family="Times", size=15),
axis.text= element_text(family="Times", size=12),
strip.text.x= element_text(family="Times", size=12),
strip.text.y= element_text(family="Times", size=12),
legend.title = element_text(family="Times", size=15),
legend.position="None",
plot.title = element_text(family="Times", size=15, hjust = 0.5))
}else{
selective.plt = NULL
}
}
if (verbose){ # print summary table
cat("\n")
cat("Summary of post-selective decomposition for replication diagnosis:")
cat("\n\n")
print(ret_table_sel)
cat("\n")
if (!is.null(selective.plt)){
print(selective.plt)
}
}
}
ret_table_sel$Component <- rownames(ret_table_sel)
ret_table_sel <- ret_table_sel[, c("Component", "low", "high", "estimate")]
colnames(ret_table_sel) = c("Component", "CI.Low", "CI.High", "Estimate")
ret_table_sel$Estimate[ret_table_sel$Estimate==-Inf] = "NULL"
if (nchar(sel.message)>0){
cat(sel.message)
}
return(list("plot" = decomp.plot, "table" = ret_table_df,
"plot_selective" = selective.plt, "table_selective" = ret_table_sel,
"message_selective" = sel.message))
}
results = run_diagnosis(
org_df = org.dat,
rep_df = rep.dat,
analysis_formula = analysis_formula,
treatment_name = treatment_name,
id_name_1 = "X",
id_name_2 = "X",
covariates = covariates,
mediators = mediators,
alpha = 0.1, # confidence level for all CIs
verbose = TRUE, # printing the tables and plots
if_selective = TRUE, # conduct the selective inference CIs
pub_pvalue_threshold = 0.05, # p-value threshold for publication bias
)
devtools::document()
rm(list = c("run_diagnosis"))
devtools::document()
devtools::build()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
.Last.error
.Last.error
devtools::build()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
